# Edge E2E wrappers

WARNING: this document contains credentials.  Do not share externally.

## per-language wrapper structure: high-level organization
All language wrappers are located in, where else, but the wrappers directory.  All wrappers have the following structure:
1. `dockerfiles.linux` has the dockerfiles we use to build containers when it's time to run the wrapper inside of a docker container.
2. `wrapper` has the source code for the wrapper.  More on the contents of this directory later.
3. `prep-for-debug.cmd` is a script that builds everything you need to debug the wrapper locally.  This accepts a path to the local copy of the SDK repo that you want to use.  This script will build the SDK and the wrapper (or whatever needs to happen to prepare the wrapper to run)

```
F:\repos\internals\edge-e2e\wrappers\csharp>prep-for-debug.cmd f:\repos\csharp

BUILD: --- Shared Assembly Debug ---
Microsoft (R) Build Engine version 15.7.179.6572 for .NET Core
<<<snip>>
    0 Error(s)

Time Elapsed 00:00:06.52
success
```

4. `run.cmd` launches the wrapper server.  Since you'll probably be running the wrapper inside of a debugger, this script isn't too useful.
```
F:\repos\internals\edge-e2e\wrappers\csharp>run
Using launch settings from F:\repos\internals\edge-e2e\wrappers\csharp\wrapper\aspnetcore-server\src\IO.Swagger\Properties\launchSettings.json...
info: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[0]
      User profile is available. Using 'C:\Users\bertk\AppData\Local\ASP.NET\DataProtection-Keys' as key repository and Windows DPAPI to encrypt keys at rest.
Hosting environment: Development
Content root path: F:\repos\internals\edge-e2e\wrappers\csharp\wrapper\aspnetcore-server\src\IO.Swagger
Now listening on: http://localhost:5000
Application started. Press Ctrl+C to shut down.
```

## per-langauge wrapper structure: source code organization
Each language is a little different.  In general, all have:
1. Some wrapper code generated by the swagger.io codegen tools.  In most cases, we have a copy of the entire package that was generated.  For C, we just have a copy of the .cpp & .h that we care about.
2. The generated wrappers are in a default*.* file somewhere in the wrapper directory.  (The location varies by SDK.  You can find it.)  specifically:

| SDK    | default wrapper       |
|--------|-----------------------|
| C      | DefaultApi.cpp        |
| C#     | DefaultApi.cs         |
| Node   | DefaultService.cs     |
| Python | default_controller.py |

These files are generated by the codegen tools, and then modified by hand to call into the glue code.  If you're not adding new functions or changing glue interfaces, you shouldn't modify the default wrappers.  All of the interesting code is in the glue files.
3. Each SDK (client, service, registry, and eventhub) has a glue file.  This is usually in the same directory as the default wrapper, but in python it's closer to the root.  Each restapi function has a corresponding function in the glue object.  In some cases, all glue objects have been defined and the wrapper is updated to call into the glue.  In other cases, only the module glue has been completely stubbed and other glue files are missing.
4. Each glue file has an object for the specific SDK.  For example, ModuleGlue.cs has all of the ModuleClient functions inside of it.  This is where most of the SDK-specific code will go.
5. Inside the glue object is an objectmap.  This is used to give names to objects.  For example,  when connecting to a ModuleClient instance in Node, the ModuleClient object is inserted into the objectMap as moduleClient_1.  Any time the restapi wants to call a function on  that moduleClient instance, it has connectionId=moduleClient_1 in the URI and the module glue can use the objectMap to map moduleClient_1 to the Node object.

## your first run with your wrappers
When you launch your wrappers locally, it will give you a URI.  In most cases, this URI is in console output.  For C#, use root URI that comes up in the browser window after you press F5 inside of IO.Swagger.sln.  On my machine, it's `http://localhost:50352` though I don't know the significance of that number.

Inside of environment.py, you have 2 options:
1. if you want to use this URI for only ModuleClient APIs, set `override_test_module_host`: `override_test_module_host = 'http://localhost:50352``
2. If you want to use this URI for ALL apis, set `edge_test_container`.  This won't be useful until you have most (or all) glue functions for most (or all) glue modules implemented.

Since you're debugging on your dev box, you also need to connect using a connections string.  Make sure `test_module_connection_string` in environment.py is correct.  Also make sure `test_module_connect_from_environment` is set to false.

You'll also need to make sure you have the CA cert set correctly.  Get it using `cat /var/lib/iotedge/hsm/edge_owner_ca.cert.pem` on your edgeHob box.  For the Node SDK, you'll need to paste this into environment.py.  For python, C, and C#, you'll need to import this into your trusted cert store as a trusted root CA (either machine or user).

As configured at this point, the test runner should use your SDK that is running in the debugger for all ModuleClient calls.  It will use the Node.js modules running inside containers your edgeHub host for the service, registry, and eventhub API calls.  It also uses the NodeJs container module named `friendMod` for any tests that require a second container.

If you use pytest to run test_connect_disconnect.py, you should see activity in the debugger.  You should see the connect and disconnect functions inside the module glue get hit, and these should be calling into your API to successfully connect and disconnect your clients from the edgeHub.

If this works, and if it succeeds, and if you see your code get hit, then you're golden.  You can start running tests and exercising your wrapper code.

## guidelines
Aside from all the usual programming platitudes:
1. Instrument the heck out of your code with debugging spew.  Send it to the console.  Use Console.WriteLine, printf, cout, etc.  When the execution is fully automated, we will be harvesting this output for post-mortem debugging.  If you need any environment variables set (e.g. DEBUG for node.js), we can add them to prep-for-debug.cmd and to the dockerfile for your language.
2. APIs with wrapper/ in the path are reserved for future use.  This is where we will put per-language suite-init code, inter-test validation, and end-of-suite validation.  For example, this is where we make sure all client objects were actually closed and this is also where we will run tools like valgrind.  (Yes, there are issues with the wrapper executable lifetime here.  I have plans for this.)
3. Do not commit NuGet.Config to the repo.  This is changed by the C# prep-for-debug.cmd and will break container builds if committed.  (I hope to change the build so it doesn't cause problems, but that's a problem for a different tim e)


